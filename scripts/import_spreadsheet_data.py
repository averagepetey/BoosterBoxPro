#!/usr/bin/env python3
"""
Import spreadsheet data into leaderboard.json
Maps spreadsheet columns to our data structure
"""

import json
import sys
from pathlib import Path
from typing import Dict, List, Any
import re

def parse_set_name(set_str: str) -> Dict[str, str]:
    """
    Parse set name like "(OP-01) Romance Dawn (Blue)" into components
    Returns: {product_name, set_name, set_code}
    """
    # Extract set code (OP-01, EB-01, etc.)
    code_match = re.search(r'\(([A-Z]+-\d+)\)', set_str)
    set_code = code_match.group(1) if code_match else None
    
    # Extract variant (Blue, White) if present
    variant_match = re.search(r'\((Blue|White)\)', set_str)
    variant = variant_match.group(1) if variant_match else None
    
    # Extract set name (text between code and variant)
    if variant:
        set_name_match = re.search(r'\)\s*([^(]+)\s*\(', set_str)
    else:
        set_name_match = re.search(r'\)\s*(.+?)(?:\s*$)', set_str)
    set_name = set_name_match.group(1).strip() if set_name_match else set_str
    
    # Build product name
    if variant:
        product_name = f"One Piece - {set_code} {set_name} Booster Box ({variant})"
    else:
        product_name = f"One Piece - {set_code} {set_name} Booster Box"
    
    return {
        "product_name": product_name,
        "set_name": set_name,
        "set_code": set_code,
        "variant": variant
    }

def parse_price(price_str: str) -> float:
    """Parse price string like '$3,998.49' to float"""
    return float(price_str.replace('$', '').replace(',', ''))

def parse_number(num_str: str) -> float:
    """Parse number string, handling commas"""
    return float(str(num_str).replace(',', ''))

def create_box_data(
    row_data: Dict[str, Any],
    rank: int,
    box_id: str
) -> Dict[str, Any]:
    """
    Create a box data entry from spreadsheet row
    """
    set_info = parse_set_name(row_data.get('Set', ''))
    
    market_price = parse_price(row_data.get('Market Price', '0'))
    leg_up_price = parse_price(row_data.get('20% Leg Up', '0'))
    supply = int(parse_number(row_data.get('BB Supply', '0')))
    daily_sold_avg = parse_number(row_data.get('Average Daily Sold (28-day average)', '0'))
    days_inventory = parse_number(row_data.get('Days of Inventory Remaining', '0'))
    
    # Calculate days to 20% increase (if we have leg up price)
    days_to_20pct = None
    if leg_up_price > market_price and daily_sold_avg > 0:
        # Rough estimate: days to 20% = (leg_up_price - market_price) / (daily_sold_avg * price_change_per_day)
        # This is simplified - you may want to adjust based on your actual calculation
        days_to_20pct = days_inventory  # Using inventory days as proxy for now
    
    # Calculate estimated total supply (if we have supply and listed percentage)
    # For now, we'll estimate based on supply
    estimated_supply = supply * 10 if supply > 0 else 10000  # Rough estimate
    
    # Calculate listed percentage (supply / estimated supply)
    listed_percentage = (supply / estimated_supply * 100) if estimated_supply > 0 else 0
    
    # Calculate liquidity score (simplified - based on supply and sales velocity)
    # Higher supply + higher sales = higher liquidity
    liquidity_score = min(100, max(0, (supply * 0.1 + daily_sold_avg * 10)))
    
    # Generate price sparkline (simplified - just use market price with small variations)
    sparkline_prices = [
        market_price * 0.98,
        market_price * 0.99,
        market_price * 0.995,
        market_price,
        market_price * 1.005,
        market_price * 1.01,
        market_price
    ]
    
    return {
        "id": box_id,
        "rank": rank,
        "rank_change_direction": "same",  # Default - can be updated
        "rank_change_amount": 0,
        "product_name": set_info["product_name"],
        "set_name": set_info["set_name"],
        "game_type": "One Piece",
        "image_url": None,  # Will be generated by backend
        "metrics": {
            "floor_price_usd": market_price,
            "floor_price_1d_change_pct": 0.0,  # Default - can be updated
            "daily_volume_usd": market_price * daily_sold_avg,  # Estimated
            "unified_volume_7d_ema": market_price * daily_sold_avg * 7,  # 7-day estimate
            "units_sold_count": int(daily_sold_avg),  # Daily average
            "active_listings_count": supply,
            "listed_percentage": round(listed_percentage, 2),
            "estimated_total_supply": int(estimated_supply),
            "liquidity_score": round(liquidity_score / 100, 2),  # Convert to 0-1 scale
            "days_to_20pct_increase": days_to_20pct,
            "expected_days_to_sell": days_inventory,
            "boxes_sold_per_day": daily_sold_avg,
            "boxes_sold_30d_avg": daily_sold_avg,
            "price_sparkline_1d": [
                {"timestamp": f"2024-01-14T{i*4:02d}:00:00Z", "price": price}
                for i, price in enumerate(sparkline_prices)
            ]
        },
        "reprint_risk": "LOW",  # Default - can be updated
        "metric_date": "2024-01-15"
    }

def import_from_csv(csv_file: str, output_file: str = None):
    """
    Import data from CSV file
    CSV should have headers: Set, Market Price, 20% Leg Up, BB Supply, Average Daily Sold (28-day average), Days of Inventory Remaining
    """
    import csv
    
    if output_file is None:
        # Use data folder for real data
        data_dir = Path(__file__).parent.parent / "data"
        data_dir.mkdir(exist_ok=True)
        output_file = data_dir / "leaderboard.json"
    
    boxes = []
    
    with open(csv_file, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for rank, row in enumerate(reader, start=1):
            box_id = f"550e8400-e29b-41d4-a716-44665544{rank:04d}"
            box_data = create_box_data(row, rank, box_id)
            boxes.append(box_data)
    
    # Create the full leaderboard structure
    leaderboard_data = {
        "data": boxes,
        "meta": {
            "total": len(boxes),
            "sort": "unified_volume_7d_ema",
            "sort_direction": "desc",
            "date": "2024-01-15"
        }
    }
    
    # Write to file
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(leaderboard_data, f, indent=2, ensure_ascii=False)
    
    print(f"✅ Successfully imported {len(boxes)} boxes to {output_file}")
    return leaderboard_data

def import_from_dict_list(data: List[Dict[str, Any]], output_file: str = None):
    """
    Import data from a list of dictionaries
    Each dict should have keys: Set, Market Price, 20% Leg Up, BB Supply, Average Daily Sold (28-day average), Days of Inventory Remaining
    """
    if output_file is None:
        # Use data folder for real data
        data_dir = Path(__file__).parent.parent / "data"
        data_dir.mkdir(exist_ok=True)
        output_file = data_dir / "leaderboard.json"
    
    boxes = []
    
    for rank, row in enumerate(data, start=1):
        box_id = f"550e8400-e29b-41d4-a716-44665544{rank:04d}"
        box_data = create_box_data(row, rank, box_id)
        boxes.append(box_data)
    
    # Sort by volume (7-day EMA) descending
    boxes.sort(key=lambda x: x["metrics"]["unified_volume_7d_ema"] or 0, reverse=True)
    
    # Re-assign ranks based on sorted order
    for rank, box in enumerate(boxes, start=1):
        box["rank"] = rank
    
    # Create the full leaderboard structure
    leaderboard_data = {
        "data": boxes,
        "meta": {
            "total": len(boxes),
            "sort": "unified_volume_7d_ema",
            "sort_direction": "desc",
            "date": "2024-01-15"
        }
    }
    
    # Write to file
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(leaderboard_data, f, indent=2, ensure_ascii=False)
    
    print(f"✅ Successfully imported {len(boxes)} boxes to {output_file}")
    return leaderboard_data

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python import_spreadsheet_data.py <csv_file>")
        print("Or provide data as JSON: python import_spreadsheet_data.py --json <json_file>")
        sys.exit(1)
    
    if sys.argv[1] == "--json":
        with open(sys.argv[2], 'r') as f:
            data = json.load(f)
        import_from_dict_list(data)
    else:
        import_from_csv(sys.argv[1])

